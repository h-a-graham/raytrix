---
output: 
  github_document:
    fig_width: 7.5
    fig_height: 6
  html_preview: false
editor_options: 
  chunk_output_type: console
---


------------
```{r setup, include = FALSE}
library(knitr)
library(rgl)
knit_hooks$set(rgl = hook_rgl)
knitr::opts_chunk$set(
  fig.path = "man/figures/",
  cache = TRUE
)
set.seed(1001)
```
Raytrix
=========================================================
A {rayshader} plugin providing a spatial framework and convenience functions for 
accessing spatial data. This is similar to and may replace [{ryavista}](https://github.com/h-a-graham/rayvista). 
But things are still very much under development.

```{r hexData, echo=FALSE,results='hide',fig.keep='all', message=FALSE, warning=FALSE, results='hide'}
library(raytrix)
library(rayshader)
library(scico)
library(sf)
library(graticule)

prj <- '+proj=tpeqd +lat_1=60 +lat_2=65'

grat <- st_graticule() %>%
  st_transform(prj) %>%
  st_geometry() %>%
  st_as_sf() %>%
  st_union()

grat_area <- st_as_sf(graticule(proj = prj, tiles=T)) %>%
  st_make_valid() %>%
  st_union()
grat_area <-  st_multipolygon(lapply(grat_area, function(x) x[1])) %>%st_geometry() %>%
  st_as_sf(crs=prj)

# plot(grat_area, col='red')
# plot(st_geometry(grat), add=T)

set_canvas_sf(grat_area)

gebco <- topo_matrix(2e4,
                     src = '/vsicurl/https://public.services.aad.gov.au/datasets/science/GEBCO_2019_GEOTIFF/GEBCO_2019.tif',
                     resample = 'average',
                     warp_options=c("SOURCE_EXTRA=360")
                     )

biasTurbo <- function(bias, direction, n=256){
  pal <- colorRampPalette(viridisLite::turbo(n, direction=direction), bias=bias)
  return(pal(n))
}

bathypal <- scico(256, palette = 'oslo')
bathy_hs = height_shade(gebco, texture = bathypal)

diamonMap <- gebco %>%
  height_shade(texture = scico(512, palette = 'vikO', direction=1))%>%
  add_overlay(generate_altitude_overlay(bathy_hs, gebco, 0, 0), alphalayer = 1)  %>%
  add_shadow(ray_shade(gebco,zscale=1e4*1e-2, sun_angle=10, multicore = T),0) %>%
  add_shadow(texture_shade(gebco, detail = 0.8, contrast=5, brightness=10),0) %>%
  add_overlay(generate_line_overlay(grat, canvasExent(),gebco, color = 'grey90'), rescale_original = T, alphalayer = 0.9) 

plot_3d(diamonMap, gebco, zscale=2e4, baseshape='hex', windowsize = 1000,
        theta = -90, phi = 89, fov = 0, zoom = 0.65)

render_depth(title_text = "raytrix",
             title_font = 'Megrim',
             title_offset = c(300, 150),
             title_color = 'grey80',
             title_size = 120,
             fstop = 1,
             focallength = 50,
             bokehshape='hex',
             zscale =1*1e-1,
             print_scene_info=FALSE)

# render_highquality(filename = 'ideas/hex.png',
#                    lightdirection = c(0, 60,110, 240),
#                    lightaltitude=c(-45, 90,25, 12),
#                    lightintensity=c(700, 100, 500, 450),
#                    lightcolor = c('#FFCE9A',"white", "#FF9956", "#73A7E1"),
#                    environment_light = 'data/syferfontein_1d_clear_4k.hdr', # download from: https://polyhaven.com/hdris/sunrise-sunset
#                    # cache_filename=cache_f,
#                    samples =100,
#                    title_text = "raytrix",
#                    title_font = 'Megrim',
#                    title_offset = c(200, 80),
#                    title_color = 'grey90',
#                    title_size = 120)

rgl::rgl.close()
```

### Quick Introduction

**Install**
```
devtools::install_github('h-a-graham/raytrix')
```

**Project Canvas:**
with {raytrix} we must first set out a strict geospatial region which define the 
bounds of the area to be mapped; This is referred to as the canvas. This can be 
achieved by direct input or with a spatial oject (currently sf and RasterLayer, 
RasterBrick). global values are set of extent and projections which can be 
viewed with get_canvas(). An Extent object can be produced and be used with 
{rayshader} functions such as `generate_overlay`.

```
set_canvas(xmin, ymin, xmax, ymax, crs)  # basic argument for setting canvas - Done
set_canvas_raster(raster/terra/stars)  # set canvas from a raster data class - Not Done
set_canvas_sf(sf/sfc, mask = FALSE)  # set canvas from an sf/sfc object - Done
set_canvas_centroid(long, lat, radius, crs=4326)  # set canvas from cetroid and radius - Done (although will probably change)
get_canvas()  # retrieves the extent and crs parameters if required for additional steps... - Done
canvasExtent() # get an object of class Extent for using in other {rayshader} functions - Done
```

**Data:**
Now you can use {aytrix} to warp raster data from online or on-disk sources using
the awesome [{vapour}](https://hypertidy.github.io/vapour/) package.
These functions enable the retrieval of topographic (or other single band raster) 
and overlay (3-band raster data) data in a "rayshader-ready" format. 
i.e. matrix for the `topo_matrix` and 4 dimensional 
array for the `map_drape` (4th dim being alpha).

```
topo_matrix(res, src='aws', ...)  
map_drape(res, src='esri.aerial', alpha=1 ...) # many options now available here - need to check in on API Key requirements.
```


**Example**

```{r MtStHelens, message=FALSE, warning=FALSE, results='hide'}
library(raytrix)
library(rayshader)

# ---- Mt St Helens ------------
.lat <- 46.200732
.long <- -122.187082
set_canvas_centroid(.lat, .long, radius = 7000)
get_canvas()$extent

tc <- topo_matrix(25, src='aws')
ov <- map_drape(5, src='wms_virtualearth', alpha=0.4, resample = 'CubicSpline')

texture <- tc %>%
  sphere_shade(texture='imhof4')%>%
  add_overlay(., ov,rescale_original=T) %>%
  add_shadow(ray_shade(tc, zscale=7, sunangle=175, multicore = T), 0.5) %>%
  add_shadow(texture_shade(tc, detail=0.8, contrast = 10, brightness = 15),0)
plot_3d(texture, tc, zscale=25*0.75,  windowsize = 1000,
        theta=150, phi=25, zoom=0.7, fov=50)

render_snapshot()
rgl::rgl.close()
```

